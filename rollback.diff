diff --git a/modules/scheduler.py b/modules/scheduler.py
index 98c82c0..e323270 100644
--- a/modules/scheduler.py
+++ b/modules/scheduler.py
@@ -249,7 +249,7 @@ def programar(df_ordenes, cfg, start=date.today(), start_time=None, debug=False)
             if maq_locked not in maquinas and maq_locked not in ["TERCERIZADO", "SALTADO", "POOL_DESCARTONADO"]:
                  continue
 
-            mask = (tasks["OT_id"].astype(str) == str(ot)) & (tasks["Proceso"].astype(str) == str(proc))
+            mask = (tasks["OT_id"].astype(str) == str(ot)) & (tasks["Proceso"].astype(str) == str(proc)) & ~(tasks["Maquina"].isin(["SALTADO", "TERCERIZADO"]))
             
             if mask.any():
                 tasks.loc[mask, "Maquina"] = maq_locked
@@ -298,7 +298,7 @@ def programar(df_ordenes, cfg, start=date.today(), start_time=None, debug=False)
                 mask_proc = pd.Series([True] * len(tasks), index=tasks.index) 
 
             # Apply
-            mask_final = mask_ots & mask_proc
+            mask_final = mask_ots & mask_proc & ~(tasks["Maquina"].isin(["SALTADO", "TERCERIZADO"]))
             
             if mask_final.any():
                 tasks.loc[mask_final, "Maquina"] = maq_target
@@ -313,10 +313,6 @@ def programar(df_ordenes, cfg, start=date.today(), start_time=None, debug=False)
     iberica = [m for m in troq_cfg["Maquina"].tolist() if "iberica" in str(m).lower()]
     auto_names = [m for m in troq_cfg["Maquina"].tolist() if "autom" in str(m).lower() or "duyan" in str(m).lower()]
     auto_name = auto_names[0] if auto_names else None
-
-    # DEBUG DOWNTIMES
-    print(f"DEBUG: Maquinas activas Troquelado: {manuales + ([auto_name] if auto_name else [])}")
-    print(f"DEBUG: Downtimes en CFG: {len(cfg.get('downtimes', []))}")
     for dt in cfg.get("downtimes", []):
         print(f"  - {dt}")
 
@@ -341,7 +337,7 @@ def programar(df_ordenes, cfg, start=date.today(), start_time=None, debug=False)
             for m in cap.keys()
         }
 
-        mask_troq = tasks["Proceso"].eq("Troquelado")
+        mask_troq = tasks["Proceso"].eq("Troquelado") & ~(tasks["Maquina"].isin(["SALTADO", "TERCERIZADO"]))
         
         # EXCLUDE Manual Assignments logic
         if "ManualAssignment" in tasks.columns:
@@ -487,52 +483,7 @@ def programar(df_ordenes, cfg, start=date.today(), start_time=None, debug=False)
         # Todas las tareas van a un "buzón" común llamado "POOL_DESCARTONADO".
         # Las máquinas tomarán tareas de ahí a medida que se liberen.
         
-        mask_desc = tasks["Proceso"].eq("Descartonado")
-        
-        # EXCLUDE Manual Assignments logic
-        if "ManualAssignment" in tasks.columns:
-            mask_desc = mask_desc & (~tasks["ManualAssignment"])
-        tasks.loc[mask_desc, "Maquina"] = "POOL_DESCARTONADO"
-
-    # =================================================================
-    # 4. CONSTRUCCIÓN DE COLAS INTELIGENTES
-    # =================================================================
-
-    colas = {}
-    buffer_espera = {m: [] for m in maquinas} # Buffer para Francotirador
-    
-    for m in maquinas:
-        q = tasks[tasks["Maquina"] == m].copy()
-        m_lower = m.lower()
-        
-        if q.empty: colas[m] = deque()
-        elif ("troquel" in m_lower) or ("duyan" in m_lower) or ("manual" in m_lower): colas[m] = _cola_troquelada(q)
-        elif ("offset" in m_lower) or ("heidelberg" in m_lower): colas[m] = _cola_impresora_offset(q)
-        elif ("flexo" in m_lower) or ("impres" in m_lower): colas[m] = _cola_impresora_flexo(q)
-        elif "bobina" in m_lower: colas[m] = _cola_cortadora_bobina(q)
-        else: 
-            # Orden por defecto: ManualPriority -> Agrupados -> New Urgent -> Soft Locked -> Urgente -> DueDate -> Orden Proceso -> Cantidad
-            # Standard sorting
-            q.sort_values(by=["ManualPriority", "Urgente", "DueDate", "_orden_proceso", "CantidadPliegos"], 
-                          ascending=[True, False, True, True, False], inplace=True)
-            colas[m] = deque(q.to_dict("records"))
-
-    # Crear la cola del POOL si existe
-    if "POOL_DESCARTONADO" in tasks["Maquina"].values:
-        q_pool = tasks[tasks["Maquina"] == "POOL_DESCARTONADO"].copy()
-        
-        q_pool.sort_values(by=["ManualPriority", "Urgente", "DueDate", "_orden_proceso", "CantidadPliegos"], 
-                           ascending=[True, False, True, True, False], inplace=True)
-        colas["POOL_DESCARTONADO"] = deque(q_pool.to_dict("records"))
-    else:
-        colas["POOL_DESCARTONADO"] = deque()
-
-    # =================================================================
-    # 5. LÓGICA DE PLANIFICACIÓN (EL NÚCLEO)
-    # =================================================================
-    
-    pendientes_por_ot = defaultdict(set); [pendientes_por_ot[t["OT_id"]].add(t["Proceso"]) for _, t in tasks.iterrows()]
-    
+        mask_desc = tasks["Proceso"].eq("Descartonado") & ~(tasks["Maquina"].isin(["SALTADO", "TERCERIZADO"]))
     # Pre-compute skipped process set for fast lookup in verificar_disponibilidad
     # This allows downstream processes (e.g. Descartonado) to bypass skipped dependencies
     def _clean_for_skip(s):
